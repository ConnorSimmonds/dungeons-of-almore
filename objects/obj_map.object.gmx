<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>STATE_MINIMAP = 0;
STATE_DRAW = 1;
STATE_CLOSE = 2;

//Map Drawing Constants
MAP_DRAW = 1;
MAP_REMOVE = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var mapX;
for(mapX = 0; mapX &lt;= room_width/32; mapX++){
    map[mapX,room_height/32] = 0;
}

state = STATE_MINIMAP;
playerDir = scr_get_playerDir();
debug = false;
draw_tool = MAP_DRAW;

miniX = view_wview[0]-(global.guiScale*(sprite_get_width(spr_map_background)*(11/10)))
miniY = (global.guiScale*(sprite_get_height(spr_map_background)*(1/4)));


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(keyboard_check_pressed(ord('A'))){
    scr_map_open();
} else if(keyboard_check_pressed(ord('S'))){
    scr_map_minimize();
}

if(state == STATE_DRAW){
    if(mouse_check_button_pressed(mb_left)){
        var mapX, mapY;
        mapX = floor(window_mouse_get_x()/32)
        mapY = floor(window_mouse_get_y()/32)
        map[mapX,mapY] = draw_tool;
        //We call the script to send our message through to our server
        with(obj_network){
            scr_handle_messages('3',mapX,mapY,draw_tool);
        }
    }
    
    if(keyboard_check_pressed(vk_numpad1)){
    draw_tool = MAP_DRAW;
    }
    if(keyboard_check_pressed(vk_numpad2)){
        draw_tool = MAP_REMOVE;
    }
}

if(keyboard_check_pressed(ord('D'))){
    debug = !debug;
    show_debug_message("Debug is " + string(debug));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var mapX, mapY;
if(state == STATE_DRAW){
    scr_draw_sprite_tiled_restrain(spr_map_background, 0, 0, 0, 168, 168, 1, c_white, 0.25)
    for(mapX = 0; mapX &lt; array_height_2d(map); mapX++){
        for(mapY = 0; mapY &lt; array_length_2d(map,mapX); mapY++){
            draw_sprite(spr_tiles,map[mapX,mapY],mapX*32,mapY*32);
        }
    }
    draw_sprite(spr_playerIcon,playerDir,obj_player.x-16,obj_player.y-16);
} else if(state == STATE_MINIMAP){
    draw_sprite_ext(spr_map_background,0,miniX,miniY,global.guiScale,global.guiScale,0,c_white,0.1);
    
    for(mapX = 0; mapX &lt; 4; mapX++){
        for(mapY = 0; mapY &lt; 4; mapY++){
            if(mapX &gt;= array_height_2d(map) || mapY &gt;= array_length_2d(map,mapX)){
                //we draw nothing you bozos
            } else {
                var chunkX, chunkY;
                //gets the chunk we're in, for the displacement
                chunkX = floor((obj_player.target_x/32)/4);
                chunkY = floor((obj_player.target_y/32)/4); 
                draw_sprite_ext(spr_tiles,map[(chunkX*4)+mapX,(chunkY*4)+mapY],miniX+ (32 * mapX),miniY+ (32 * mapY),global.guiScale,global.guiScale,0,c_white,0.25);
            }
        }
        draw_sprite_ext(spr_playerIcon,playerDir,floor(miniX + floor(((obj_player.target_x/32) mod 4))* 32),floor(miniY+floor(((obj_player.target_y/32) mod 4))*32),global.guiScale,global.guiScale,0,c_white,0.25);
    }
} else {

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
